//문제1

class PlayingCard {
	

int kind; //인스턴스변수
int num;  // 인스턴스변수 
//----------------------- Heap ==> 프로그램 종료시까지 유지 => 멤버변수 =8byte
//						  new 사용시 메모리가 따로 배정
static int width; // 정적변수
static int height; //정적변수
//------------------------- 정적변수 => 공유변수 => MethodArea 프로그램 종료시까지 유지

 PlayingCard(int k, int n) { 
kind = k; //지역변수
num = n;  //지역변수 => 매개변수 => 지역변수 일종 => stack: 메모리 자체 관리 ={} 종료되면 자동 삭제
 }
}
 //문제2
class student5
{
	String name;
	int ban;
	int no;
	int kor;
	int eng;
	int math;
}

 
//문제 3 다음 중 생성자에 대한 설명으로 옳지 않은 것은? (모두 고르시오).
 
/* 
 *	특징 1) 클래스명과 동일 2) 여러개 생성이 가능(오버로딩) 3) 역할 => 객체생성시에 호출, 변수에 초기화
* a. 모든 생성자의 이름은 클래스의 이름과 동일해야한다.
*  b. 생성자는 객체를 생성하기 위한 것이다.
*  c. 클래스에는 생성자가 반드시 하나 이상 있어야 한다.V => 생략가능
*  d. 생성자가 없는 클래스는 컴파일러가 기본 생성자를 추가한다.
*  e. 생성자는 오버로딩 할 수 없다.V
*/
 
//문제 4 다음 중 this에 대한 설명으로 맞지 않은 것은? (모두 고르시오)
 
 /*
  * this는 모든 클래스에 존재 => static => 자신을 가르키는 참조변수
  * a. 객체 자신을 가리키는 참조변수이다 
  * b. 클래스 내에서라면 어디서든 사용할 수 있다.V
  * c. 지역변수와 인스턴스변수를 구별할 때 사용한다. 
  * d. 클래스 메서드 내에서는 사용할 수 없다.
  * 
  * 클래스 메소드 => static 메소드는 사용할 수 없다
  */
 
 //문제 5 다음 중 오버로딩이 성립하기 위한 조건이 아닌 것은? (모두 고르시오).
 /*
  * 중복 메소드의 정의 : 같은 메소드명으로 새로운 기능을 추가 => 오버로딩
  * 
  * 1)메소드명 동일
  * 2) 매개변수의 개수나 타입이 달라야한다
  * 3)리턴형은 관계없다
  * 4) 접근지정어도 관계없다
  */
 /*
  * a. 메서드의 이름이 같아야 한다
  * b. 매개변수의 개수나 타입이 달라야 한다
  * c. 리턴타입이 달라야 한다. V
  * d. 매개변수의 이름이 달라야 한다. V
  */
 
//문제 6 오버로딩의 조건
// 1. (  메소드   ) 이름이 같아야 한다.
//2. ( 매개변수 )의 개수 또는 타입이 달라야 한다.
//3. 매개변수는 같고 (   리턴형    )이 다른 경우는 오버로딩이 성립되지 않는다.   

//문제 7 	다음 중 아래의 add메서드를 올바르게 오버로딩 한 것은? (모두 고르시오)
 /*
  * 예시) long add(int a, int b) { return a+b; }
  * a. long add(int x, int y) { return x+y; } //같은 데이터형을 똑같이 써서 X
  * b. long add(long a, long b) { return a+b; } V
  *	c. int add(byte a, byte b) { return a+b; } V
  *	d. int add(long a, int b) { return (int)(a+b); } V
  */
 //문제 8 다음 중 초기화에 대한 설명으로 옳지 않은 것은? (모두 고르시오).
 /*
  * class에서 초기화
  * 
  *
  * 
  * => class A {
  * 	int a = 0
  * 	string m =null 
  * 	boolean b = fals
  * 	long l =0L
  *     double d = 0.0
  *     }
  * 
  * a. 멤버변수는 자동 초기화되므로 초기화하지 않고도 값을 참고할 수 있다.
  * b. 지역변수는 사용하기 전에 반드시 초기화해야 한다.  => 지역변수는 초기화가 안됨
  * 	//기본값 => 명시적 초기화 => static 블록 => 인스턴스 블록 => 생성자
  * c. 초기화 블럭보다 생성자가 먼저 수행된다.  V
  * d. 명시적 초기화를 제일 우선적으로 고려해야 한다. => String dirver, username.password => 오라클
  * e. 클래스변수보다 인스턴스변수가 먼저 초기화된다. V
  */
 
//문제 9 다음 중 인스턴스변수의 초기화 순서가 올바른 것은?
/* a. 기본값-명시적초기화-초기화블럭-생성자  V
 * b. 기본값-명시적초기화-생성자-초기화블럭 
 * c. 기본값-초기화블럭-명시적초기화-생성자
 * d. 기본값-초기화블럭-생성자-명시적초기화
 */

// 문제 10 다음 중 지역변수에 대한 설명으로 옳지 않은 것은? (모두 고르시오)
// a. 자동 초기화되므로 별도의 초기화가 필요없다. V
// b. 지역변수가 선언된 메서드가 종료되면 지역변수도 함께 소멸된다.
// c. 메서드의 매개변수로 선언된 변수도 지역변수이다.
// d. 클래스변수나 인스턴스변수보다 메모리 부담이 적다.
// e. 힙(heap)영역에 생성되며 가비지컬렉터에 의해 소멸된다.V => stack에 자동 소멸


// 문제11. 현실 세계의 회원을 Member 클래스로 모델링하려고 합니다. 
//	회원의 데이터로는 이름, 아이디, 패스워드, 나이가 있습니다. 
//  이 데이터들을 가지는 Member 클래스를 선언해보세요.

/* 
 * 이름 	 name 	 문자열 
 * 아이디	 id	 문자열 
 * 패스워드	 password	 문자열 
 * 나이	 age	 정수 
 */
class Member
{
	String name;
	String id;
	String password;
	int age;
}

 // 문제 12. 위에서 작성한 Member 클래스에 생성자를 추가하려고 합니다. 다음과 같이 Member 객체를 생성할 때 
 // name 필드와 id 필드를 외부에서 받은 값으로 초기화하려면 생성자를 어떻게 선언해야 합니까?



public class 객체지향문제 {
	
}
