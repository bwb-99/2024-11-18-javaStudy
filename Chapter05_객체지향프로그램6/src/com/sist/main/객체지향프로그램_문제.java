package com.sist.main;
/*
 * 	1. 객체 / 클래스
 * 	건축
 * 	---
 * 	  설계 ===> 시공 ===> 완성
 * 	  ---
 * 	  class 
 */
import java.util.Scanner;
/*
 * 	문제 1 객체와 클래스에 대한 설명으로 틀린 것은 무엇입니까? 
	1) 클래스는 객체를 생성하기 위한 설계도(청사진)와 같은 것이다.
	   ---- 설계 
	   		자재 => 변수
	   		기술 => 메소드
	2) new 연산자로 클래스의 생성자를 호출함으로써 객체가 생성된다.
		클래스 객체명 = new 생성자();
		-----------------------
		Class clasName=Class.forName("클래스") => 리플렉션 => 객체 생성
				=> 메소드, 멤버변수, 생성자 => 제어가 가능
	3) 하나의 클래스로 하나의 객체만 생성할 수 있다. V
		New를 사용하면 개체는 언제든 생성
		설계(class)1개 => 여러개 객체 생성
	4) 객체는 클래스의 인스턴스이다.
	     		     추상화(요구사항) => 공통된 부분을 추출
	     		 	        ------				newSawon()
	   객체(사물,Object)=> class ClassName => 컴퓨터에 저장
	   					 {					--------- 인스턴스 => 객체
	   					 	String name
	   					 	String 부서
	   					 }

 * 
 * 	문제 2 클래스의 구성 멤버가 아닌 것은 무엇입니까?
	1) 필드(field) : 멤버변수  : 초기값을 가지고 있다
	2) 생성자(constructor)  : 멤버변수의 초기화 / 객체 생성시에 호출 / 시작과 동시 처리 가능
			=> 윈도우 : 레이아웃(화면 UI), 자동 로그인, 서버 연동, 오라클 드라이버 설정
			=> 특징
				클래스명과 동일 / 리턴형이 없다 / 다른 클래스에서 사용 => public / 오버로딩
				=> 여러개를 만들 수 있다
	3) 메소드(method) : 멤버변수를 이용한 데이터 관리(기능)
		=> 다른 클래스와 통신(메세지) / 오버로딩
	 	=> 리턴형 : 실행 결과값 => 1개만 사용이 가능
	 	=> 사용자 요청한 값 : 여러개 사용 => 매개변수
	4) 로컬 변수(local variable) V : 메소드, 생성자안에서 사용 => {} 이 종료되면 사라지는 변수

 * 
 * 	문제 3 필드, 생성자, 메소드에 대한 설명으로 틀린 것은 무엇입니까?
	1) 필드는 객체의 데이터를 저장한다. : 변수(데이터 저장 공간)
	2) 생성자는 객체의 초기화를 담당한다.
	3) 메소드는 객체의 동작 부분으로, 실행 코드를 가지고 있는 블록이다. V
		{
		 	실행 코드
		}
	4) 클래스는 반드시 필드와 메소드를 가져야 한다. O
		=> 멤버변수만 가지고 있다 : 사용자 정의 데이터형 => VO,DTO
		=> 메소드만 가지고 있다 : 액션 클래스         => DAO,MODEL
		=> 변수 + 메소드 = 혼합 : 일반 클래스

 * 	
 * 	문제 4 필드에 대한 설명으로 틀린 것은 무엇입니까?
	1) 필드는 메소드에서 사용할 수 있다. => 멤버변수는 class 영역 / 다른 클래스에서도 사용이 가능
	2) 인스턴스 필드 초기화는 생성자에서 할 수 있다.
		 => 명시적 초기화
		 => 생성자
		 => 인스턴스 초기화 블록
		 Class A
		 {
		   int a =10; 명시적 초기화
		   A()  생성자
		   {
		    	A=100;
		   }
		   
		   {
		   		a=100; 인스턴스 초기화 블록
		   }
		 }
		 기본 초기값 => 명시적 초기화 => 인스턴스 초기화 블록 => 생성자
		 			 ---------- => 구현된 상태(파일읽기 , 데이터베이스, 제어문...)
	3) 필드는 반드시 생성자 선언 전에 선언되어야 한다. 
	   => 순서는 상관없다
	   Class A
	   {
	   		생성자 / 초기화 블록
	   		메소드
	   		필드
	   }
	4) 필드는 초기값을 주지 않더라고 기본값으로 자동 초기화된다. V
	  => 멤버변수
	  	int = 0, long=0L double=0.0 boolean=false String(클래스)=Null

 * 
 * 	문제 5 생성자에 대한 설명으로 틀린 것은 무엇입니까?
	1) 객체를 생성하려면 생성자 호출이 반드시 필요한 것은 아니다. V
		=> 객체 생성 => new 생성자()
	2) 생성자는 다른 생성자를 호출하기 위해 this()를 사용할 수 있다.
		this() => 자신의 생성자 호출
		=> 생성자안에서만 호출 가능
		=> 생성자 안에서 첫번째줄에서 사용
		class A
		{
			A()
			{
			}
			A(int a)
			{
				this();
				
				System.out.println("");
				System.out.println("");
			}
		}
	3) 생성자가 선언되지 않으면 컴파일러가 기본 생성자를 추가한다.
		class A
		{
			A(){} => 생성자 존재
		)
		class A
		{
			A(int a){} => 생성자 존재
		}
		class A
		{
			A(){} => 자동 첨부
		}
	4) 외부에서 객체를 생성할 수 없도록 생성자에 private 접근 제한자를 붙일 수 있다.
									  ------- 다른 클래스에서 접근 금지
		생성자 : default, public, protected, private => public

 * 
 *  문제 6 메소드에 대한 설명으로 틀린 것은 무엇입니까?
 *         리턴형 매개변수
 *  		존재  존재
 *  	    존재  존재
 *  		X    존재 => 리턴형이 없는 경우 void
 *  		X     X 
	1) 리턴값이 없는 메소드는 리턴 타입을 void로 해야 한다. 
	2) 리턴 타입이 있는 메소드는 리턴값을 지정하기 위해 반드시 return문이 있어야 한다.
	3) 매개값의 수를 모를 경우 "..."를 이용해서 매개 변수를 선언할 수 있다.  ... : 가변 매개변수, 웹 => 데이터 받는 경우(개수가 명확하지 않는 경우)
	4) 메소드의 이름은 중복해서 선언할 수 없다. V => (중복메소드 정의가 가능 => 오버로딩)

 *  
 *  문제 7 메소드 오버로딩에 대한 설명으로 틀린 것은 무엇입니까?
	1) 동일한 이름의 메소드를 여러 개 선언하는 것을 말한다.
	2) 반드시 리턴 타입이 달라야 한다. O => 리턴형은 관계없다
	3) 매개 변수의 타입, 수 순서를 다르게 선언해야 한다.
	4) 매개값의 타입 및 수에 따라 호출될 메소드가 선택된다. V

 *  
 *  문제 8 인스턴스 멤버와 정적 멤버에 대한 설명으로 틀린 것은 무엇입니까?
	1) 정적 멤버는 static으로 선언된 필드와 메소드를 말한다.
	2) 인스턴스 필드는 생성자 및 정적 블록에서 초기화될 수 있다. O
						  ------------------------ static만 사용이 가능
	3) 정적 필드와 정적 메소드는 객체 생성 없이 클래스를 통해 접근할 수 있다.V
		클래스명, 변수명 , 클래스명.메소드
	4) 인스턴스 필드와 메소드는 객체를 생성하고 사용해야 한다.
	A a=new A() => a 메소드

 *  
 *  문제 9 final 필드와 상수(static final)에 대한 설명으로 틀린 것은 무엇입니까?
	1) final 필드와 상수는 초기값이 저장되면 값을 변경할 수 없다. 
	2) final 필드와 상수는 생성자에서 초기화될 수 있다. 
	3) 상수의 이름은 대문자로 작성하는 것이 관례이다. 
	4) 상수는 객체 생성 없이 클래스를 통해 사용할 수 있다. V 

 *  
 *  문제 10 다음 클래스에서 해당 멤버가 필드, 생성자, 메소드 중 어떤 것인지 빈칸을 채우세요.
	public class Member {
    private String name; // -------------------------------------(  필드 )  
 
    public Member(String name) { } // ---------------------------(  생성자  )
    
    public void setName(String name) { } // ---------------------(  메소드  )
}
Colored by Color Scripter
*/

 //  문제 11 . 현실 세계의 회원을 Member 클래스로 모델링하려고 합니다. 
 // 		회원의 데이터로는 이름, 아이디, 패스워드, 나이가 있습니다. 이 데이터들을 가지는 Member 클래스를 선언해보세요.

class Member
{
	public void getName(String name)
	{
		Scanner scan=new Scanner(System.in);
		System.out.println("이름입력 :");
		 String in=scan.next();
	
	}
	public void getId(String id)
	{
		Scanner scan=new Scanner(System.in);
		System.out.println("이름입력 :");
		 String ip=scan.next();
		
	}
	String passward;
	int age;
}

//문제 4 3) 예시
class A
{
	A() {
		
	}
	int age;
}

  
  

public class 객체지향프로그램_문제 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Member m=new Member();
		System.out.println(m);
	}

}
